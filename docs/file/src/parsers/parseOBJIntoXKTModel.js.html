<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/parsers/parseOBJIntoXKTModel.js | xeokit-xkt-utils</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript utilities to create .XKT files"><meta property="og:type" content="website"><meta property="og:url" content="http://xeokit.io"><meta property="og:site_name" content="xeokit-xkt-utils"><meta property="og:title" content="xeokit-xkt-utils"><meta property="og:image" content="./images/logo.jpg"><meta property="og:description" content="JavaScript utilities to create .XKT files"><meta property="og:author" content="http://xeolabs.com"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="xeokit-xkt-utils"><meta property="twitter:description" content="JavaScript utilities to create .XKT files"><meta property="twitter:image" content="./images/logo.jpg"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.jpg" style="width:34px;"></a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/xeokit/xeokit-xkt-utils"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#xktmodel">XKTModel</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTEntity.js~XKTEntity.html">XKTEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTGeometry.js~XKTGeometry.html">XKTGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTMesh.js~XKTMesh.html">XKTMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTMetaObject.js~XKTMetaObject.html">XKTMetaObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTModel.js~XKTModel.html">XKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTTile.js~XKTTile.html">XKTTile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-writeXKTModelToArrayBuffer">writeXKTModelToArrayBuffer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#geometrybuilders">geometryBuilders</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxGeometry">buildBoxGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxLinesGeometry">buildBoxLinesGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildCylinderGeometry">buildCylinderGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildGridGeometry">buildGridGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildPlaneGeometry">buildPlaneGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildSphereGeometry">buildSphereGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildTorusGeometry">buildTorusGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildVectorTextGeometry">buildVectorTextGeometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parsers">parsers</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parse3DXMLIntoXKTModel">parse3DXMLIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseCityJSONIntoXKTModel">parseCityJSONIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseGLTFIntoXKTModel">parseGLTFIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseIFCIntoXKTModel">parseIFCIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseLASIntoXKTModel">parseLASIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseMetaModelIntoXKTModel">parseMetaModelIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseOBJIntoXKTModel">parseOBJIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parsePCDIntoXKTModel">parsePCDIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parsePLYIntoXKTModel">parsePLYIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSTLIntoXKTModel">parseSTLIntoXKTModel</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/parsers/parseOBJIntoXKTModel.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const regexp = {
    // v float float float
    vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
    // vn float float float
    normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
    // vt float float
    uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
    // f vertex vertex vertex
    face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
    // f vertex/uv vertex/uv vertex/uv
    face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
    // f vertex/uv/normal vertex/uv/normal vertex/uv/normal
    face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
    // f vertex//normal vertex//normal vertex//normal
    face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
    // o object_name | g group_name
    object_pattern: /^[og]\s*(.+)?/,
    // s boolean
    smoothing_pattern: /^s\s+(\d+|on|off)/,
    // mtllib file_reference
    material_library_pattern: /^mtllib /,
    // usemtl material_name
    material_use_pattern: /^usemtl /
};

const delimiter_pattern = /\s+/;

/**
 * @desc Parses OBJ file data into an {@link XKTModel}.
 *
 * @param {Object} data OBJ file data.
 * @param {XKTModel} model XKTModel to parse into.
 * @param {*} [options] Parsing options.
 */
async function parseOBJIntoXKTModel({objData, xktModel, log}) {

}


function getBasePath(src) {
    const n = src.lastIndexOf(&apos;/&apos;);
    return (n === -1) ? src : src.substring(0, n + 1);
}

function startObject(state, id, fromDeclaration) {
    if (state.object &amp;&amp; state.object.fromDeclaration === false) {
        state.object.id = id;
        state.object.fromDeclaration = (fromDeclaration !== false);
        return;
    }
    state.object = {
        id: id || &apos;&apos;,
        geometry: {
            positions: [],
            normals: [],
            uv: []
        },
        material: {
            id: &apos;&apos;,
            smooth: true
        },
        fromDeclaration: (fromDeclaration !== false)
    };
    state.objects.push(state.object);
}

function parseVertexIndex(value, len) {
    const index = parseInt(value, 10);
    return (index &gt;= 0 ? index - 1 : index + len / 3) * 3;
}

function parseNormalIndex(value, len) {
    const index = parseInt(value, 10);
    return (index &gt;= 0 ? index - 1 : index + len / 3) * 3;
}

function parseUVIndex(value, len) {
    const index = parseInt(value, 10);
    return (index &gt;= 0 ? index - 1 : index + len / 2) * 2;
}

function addVertex(state, a, b, c) {
    const src = state.positions;
    const dst = state.object.geometry.positions;
    dst.push(src[a + 0]);
    dst.push(src[a + 1]);
    dst.push(src[a + 2]);
    dst.push(src[b + 0]);
    dst.push(src[b + 1]);
    dst.push(src[b + 2]);
    dst.push(src[c + 0]);
    dst.push(src[c + 1]);
    dst.push(src[c + 2]);
}

function addVertexLine(state, a) {
    const src = state.positions;
    const dst = state.object.geometry.positions;
    dst.push(src[a + 0]);
    dst.push(src[a + 1]);
    dst.push(src[a + 2]);
}

function addNormal(state, a, b, c) {
    const src = state.normals;
    const dst = state.object.geometry.normals;
    dst.push(src[a + 0]);
    dst.push(src[a + 1]);
    dst.push(src[a + 2]);
    dst.push(src[b + 0]);
    dst.push(src[b + 1]);
    dst.push(src[b + 2]);
    dst.push(src[c + 0]);
    dst.push(src[c + 1]);
    dst.push(src[c + 2]);
}

function addUV(state, a, b, c) {
    const src = state.uv;
    const dst = state.object.geometry.uv;
    dst.push(src[a + 0]);
    dst.push(src[a + 1]);
    dst.push(src[b + 0]);
    dst.push(src[b + 1]);
    dst.push(src[c + 0]);
    dst.push(src[c + 1]);
}

function addUVLine(state, a) {
    const src = state.uv;
    const dst = state.object.geometry.uv;
    dst.push(src[a + 0]);
    dst.push(src[a + 1]);
}

function addFace(state, a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
    const vLen = state.positions.length;
    let ia = parseVertexIndex(a, vLen);
    let ib = parseVertexIndex(b, vLen);
    let ic = parseVertexIndex(c, vLen);
    let id;
    if (d === undefined) {
        addVertex(state, ia, ib, ic);

    } else {
        id = parseVertexIndex(d, vLen);
        addVertex(state, ia, ib, id);
        addVertex(state, ib, ic, id);
    }

    if (ua !== undefined) {

        const uvLen = state.uv.length;

        ia = parseUVIndex(ua, uvLen);
        ib = parseUVIndex(ub, uvLen);
        ic = parseUVIndex(uc, uvLen);

        if (d === undefined) {
            addUV(state, ia, ib, ic);

        } else {
            id = parseUVIndex(ud, uvLen);
            addUV(state, ia, ib, id);
            addUV(state, ib, ic, id);
        }
    }

    if (na !== undefined) {

        const nLen = state.normals.length;

        ia = parseNormalIndex(na, nLen);
        ib = na === nb ? ia : parseNormalIndex(nb, nLen);
        ic = na === nc ? ia : parseNormalIndex(nc, nLen);

        if (d === undefined) {
            addNormal(state, ia, ib, ic);

        } else {

            id = parseNormalIndex(nd, nLen);
            addNormal(state, ia, ib, id);
            addNormal(state, ib, ic, id);
        }
    }
}

function addLineGeometry(state, positions, uv) {

    state.object.geometry.type = &apos;Line&apos;;

    const vLen = state.positions.length;
    const uvLen = state.uv.length;

    for (var vi = 0, l = positions.length; vi &lt; l; vi++) {
        addVertexLine(state, parseVertexIndex(positions[vi], vLen));
    }

    for (var uvi = 0, uvl = uv.length; uvi &lt; uvl; uvi++) {
        addUVLine(state, parseUVIndex(uv[uvi], uvLen));
    }
}

//--------------------------------------------------------------------------------------------
// Loads MTL files listed in parsed state
//--------------------------------------------------------------------------------------------

function loadMTLs(modelNode, state, ok) {
    var basePath = state.basePath;
    var srcList = Object.keys(state.materialLibraries);
    var numToLoad = srcList.length;
    for (var i = 0, len = numToLoad; i &lt; len; i++) {
        loadMTL(modelNode, basePath, basePath + srcList[i], function () {
            if (--numToLoad === 0) {
                ok();
            }
        });
    }
}

var parseMTL = (function () {



    return function (modelNode, mtlText, basePath) {

        var lines = mtlText.split(&apos;\n&apos;);
        var materialCfg = {
            id: &quot;Default&quot;
        };
        var needCreate = false;
        var line;
        var pos;
        var key;
        var value;
        var alpha;

        basePath = basePath || &quot;&quot;;

        for (var i = 0; i &lt; lines.length; i++) {

            line = lines[i].trim();

            if (line.length === 0 || line.charAt(0) === &apos;#&apos;) { // Blank line or comment ignore
                continue;
            }

            pos = line.indexOf(&apos; &apos;);

            key = (pos &gt;= 0) ? line.substring(0, pos) : line;
            key = key.toLowerCase();

            value = (pos &gt;= 0) ? line.substring(pos + 1) : &apos;&apos;;
            value = value.trim();

            switch (key.toLowerCase()) {

                case &quot;newmtl&quot;: // New material
                    //if (needCreate) {
                    createMaterial(modelNode, materialCfg);
                    //}
                    materialCfg = {
                        id: value
                    };
                    needCreate = true;
                    break;

                case &apos;ka&apos;:
                    materialCfg.ambient = parseRGB(value);
                    break;

                case &apos;kd&apos;:
                    materialCfg.diffuse = parseRGB(value);
                    break;

                case &apos;ks&apos;:
                    materialCfg.specular = parseRGB(value);
                    break;

                case &apos;map_kd&apos;:
                    if (!materialCfg.diffuseMap) {
                        materialCfg.diffuseMap = createTexture(modelNode, basePath, value, &quot;sRGB&quot;);
                    }
                    break;

                case &apos;map_ks&apos;:
                    if (!materialCfg.specularMap) {
                        materialCfg.specularMap = createTexture(modelNode, basePath, value, &quot;linear&quot;);
                    }
                    break;

                case &apos;map_bump&apos;:
                case &apos;bump&apos;:
                    if (!materialCfg.normalMap) {
                        materialCfg.normalMap = createTexture(modelNode, basePath, value);
                    }
                    break;

                case &apos;ns&apos;:
                    materialCfg.shininess = parseFloat(value);
                    break;

                case &apos;d&apos;:
                    alpha = parseFloat(value);
                    if (alpha &lt; 1) {
                        materialCfg.alpha = alpha;
                        materialCfg.alphaMode = &quot;blend&quot;;
                    }
                    break;

                case &apos;tr&apos;:
                    alpha = parseFloat(value);
                    if (alpha &gt; 0) {
                        materialCfg.alpha = 1 - alpha;
                        materialCfg.alphaMode = &quot;blend&quot;;
                    }
                    break;

                default:
                // modelNode.error(&quot;Unrecognized token: &quot; + key);
            }
        }

        if (needCreate) {
            createMaterial(modelNode, materialCfg);
        }
    };

    function createTexture(modelNode, basePath, value, encoding) {
        var textureCfg = {};
        var items = value.split(/\s+/);
        var pos = items.indexOf(&apos;-bm&apos;);
        if (pos &gt;= 0) {
            //matParams.bumpScale = parseFloat(items[pos + 1]);
            items.splice(pos, 2);
        }
        pos = items.indexOf(&apos;-s&apos;);
        if (pos &gt;= 0) {
            textureCfg.scale = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        pos = items.indexOf(&apos;-o&apos;);
        if (pos &gt;= 0) {
            textureCfg.translate = [parseFloat(items[pos + 1]), parseFloat(items[pos + 2])];
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        textureCfg.src = basePath + items.join(&apos; &apos;).trim();
        textureCfg.flipY = true;
        textureCfg.encoding = encoding || &quot;linear&quot;;
        //textureCfg.wrapS = self.wrap;
        //textureCfg.wrapT = self.wrap;
        var texture = new Texture(modelNode, textureCfg);
        return texture.id;
    }

    function createMaterial(modelNode, materialCfg) {
        new PhongMaterial(modelNode, materialCfg);
    }

    function parseRGB(value) {
        var ss = value.split(delimiter_pattern, 3);
        return [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
    }

})();
//--------------------------------------------------------------------------------------------
// Creates meshes from parsed state
//--------------------------------------------------------------------------------------------


function createMeshes(modelNode, state) {

    for (var j = 0, k = state.objects.length; j &lt; k; j++) {

        var object = state.objects[j];
        var geometry = object.geometry;
        var isLine = (geometry.type === &apos;Line&apos;);

        if (geometry.positions.length === 0) {
            // Skip o/g line declarations that did not follow with any faces
            continue;
        }

        var geometryCfg = {
            primitive: &quot;triangles&quot;,
            compressGeometry: false
        };

        geometryCfg.positions = geometry.positions;

        if (geometry.normals.length &gt; 0) {
            geometryCfg.normals = geometry.normals;
        }

        if (geometry.uv.length &gt; 0) {
            geometryCfg.uv = geometry.uv;
        }

        var indices = new Array(geometryCfg.positions.length / 3); // Triangle soup
        for (var idx = 0; idx &lt; indices.length; idx++) {
            indices[idx] = idx;
        }
        geometryCfg.indices = indices;

        const rtcCenter = tempVec3a;

        worldToRTCPositions(geometry.positions, geometry.positions, rtcCenter);

        var readableGeometry = new ReadableGeometry(modelNode, geometryCfg);

        var materialId = object.material.id;
        var material;
        if (materialId &amp;&amp; materialId !== &quot;&quot;) {
            material = modelNode.scene.components[materialId];
            if (!material) {
                modelNode.error(&quot;Material not found: &quot; + materialId);
            }
        } else {
            material = new PhongMaterial(modelNode, {
                //emissive: [0.6, 0.6, 0.0],
                diffuse: [0.6, 0.6, 0.6],
                backfaces: true
            });

        }

        // material.emissive = [Math.random(), Math.random(), Math.random()];

        var mesh = new Mesh(modelNode, {
            id: modelNode.id + &quot;#&quot; + object.id,
            rtcCenter: (rtcCenter[0] !== 0 || rtcCenter[1] !== 0 || rtcCenter[2] !== 0) ? rtcCenter : null,
            isObject: true,
            geometry: readableGeometry,
            material: material,
            pickable: true
        });

        modelNode.addChild(mesh);
    }
}

export {parseOBJIntoXKTModel};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
